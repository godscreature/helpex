# RUBY HELPEX

## Проки, блоки и лямбды

* **block** - конструкция языка
  * можно передать в качестве аргумента
  * в качестве аргумента - можно передать только 1шт
  * записать в переменную или сохранить нельзя
* **proc** - объект
  * можно сохранить в переменную
  * можно передать в качестве аргумента
  * в качестве аргумента - можно передавать больше 1шт
  * элемент класса `Proc`
  * не проверяют кол-во элементов, которые в него передаются
  * `return` завершает выполнение кода прока и кода метода где вызван
* **lambda** - объект
  * элемент класса `Proc`
  * проверяет кол-во элементов, которые в нее передаются
  * `return` завершает выполнение кода лямбды, код метода где вызвана - продолжает выполняться

## Области видимости переменных

* `var` - локальная, доступна только в области видимости, где была определена + во вложенных
* `@var` - переменная объекта (экземпляра), доступны в экземпляре и вложенных областях видимости
* `@@var` - переменная класса, доступны в классе и все экземпляры класса
* `$var` - глобальная переменная, доступны во всей программе
* `CONST` - область видимости
  * класс + потомки - `A::ABC`
  * модуль - `M::ABC`, но не через вложенные модули `M::M2::ABC` 
  * если модуль `prepend`/`include` в класс, то видно через:
    * класс `A::ABC`
    * потомки класса `B:ABC`
    * через модуль `M:ABC`

## Доступность методов

* **public**
  * по умолчанию
  * открытые методы - могут вызываться из любых других объектов
* **private**
  * работает почти как в ПХП
  * вызывать можно только в классе, не в экземпляре
  * также доступны наследникам
  * не могут вызываться из объектов
* **protected**
  * вызывать можно только в классе, не в экземпляре
  * работает не так как в ПХП
  * при вызове защищенного метода вызывающий класс должен быть потомком
    * можно вызывать на потомках
    * можно вызывать на самом классе
    * если в классе - ребенок этого же класа, можно вызывать `protected` методы класса в ребенке

## Модули

* **основная инфа**
  * Совокупность методов и констант
  * Методы модуля
    * могут быть методами экземпляра или методами модуля
    * когда модуль включен, меторды экземпляра появляются как методы класса, а методы модуля - нет
    * когда модуль включен,методы модуля могут вызываться без создания инкапсулирующего объекта
  * нужны для
    * **пространства имен**
    * **миксинов** - общие методы для нескольких классов или модулей
  * создается с помощью `module`
  * может быть повторно открыт для добавление добавления, изменения, удаления функционала

## Extend, prepend, include

* **include**
  * Добавляет в цепочку предков перед текущим классом - дополнительный ближайший предок.
  * Добавляет функционал инстанса
* **prepend**
  * Добавляет после текущего класса - дополнительный ближайший потомок
  * Добавляет функционал инстанса
* **extend**
  * Добавляет функционал в классовые методы

## == === equal? eql?

* **==** - общее сравнение
* **===**
  * специальная тулза, которая придумана для `case`
  * можно описать этот метод в классе, что б потом он заюзался в `case`
  * вопрос "как оно сравнивает?" не корректен, потмоу что в каждом классе реализован по-своему
  * на кастомном классе
    * > def ===(other)
      > 
      >   self == other
      > 
      > end
    * выражение после ключевого слова `case` является правой частью выражения ===
    * выражение после ключевого слова `when` находится в левой части выражения ===
* **equal?** - проверяется идентичность объектов - прям по id
* **eql?** - сравнивает хеши объектов

## is_a?, kind_of?, instance_of? - методы объекта (экземпляра)

* **instance_of?** - true, если объект является экземпляром конкретно этого класса
* **is_a?**
  * синоним с `kind_off?`
  * `a.kind_off? A` - true, если `a` - экземпляр класса `A`
  * `b.kind_off? A` - true, если `b` - экземпляр потомка класса `A`
  * `a.kind_off? ModA` true, если `a` - экземпляр класса, в котором `prepend` или `include` модуль `ModA`
  * `b.kind_off? ModA` true, если `b` - экземпляр потомка, в родителе которого `prepend` или `include` модуль `ModA`
* **kind_of?**
  * синоним с `is_a?`
  * работает так же

## Приоритетность операторов

* Приоритет по убыванию
* `!`, `~`, unary `+`
* `**`
* unary `-`
* `*`, `/`, `%`
* `+`, `-`
* `<<`, `>>`
* `&`
* `|`, `^`
* `>`, `>=`, `<`, `<=`
* `<=>`, `==`, `===`, `!=`, `=~`, `!~`
* `&&`
* `||`
* `..`, `...`
* `?`, ':'
* modifier-rescue
* `=`, `+=`, `-=`, etc
* `defined?`
* `not`
* `or`, `and`
* modifier-if, modifier-unless, modifier-while, modifier-until
* `{ }` blocks

## Safe navigation и method_name!

* Safe navigation
  * если текущее звено в цепочке методов = `nil` то дальше не идет
  * `User&.address&.street` - не упадет, если нету address или `User` пустой
* `User.create` vs `User.create!`
  * первое не создаст и вернет `nil`
  * второе не создаст и даст ошибку
* `'abs'.gsub('a','b')` vs `'abc'.gsub!('a', 'b')`
  * первое - не изменит строку, а создаст новую
  * второе - изменить саму строку - мутация

## Операторы

* Присваивания
  * `a += b` -- `a = a + b`
  * `a -= b` -- `a = a - b`
  * `a += b` -- `a = a * b`
  * `a \= b` -- `a = a \ b`
  * `a %= b` -- `a = a % b`
  * `a **= b` -- `a = a**b`
  * > a = 10
    > 
    > b = 20
    > 
    > c = 30
    > 
    > a, b, c = 10, 20, 30
* Побитовые
  * > a = 0011 1100
    > 
    > b = 0000 1101
    > 
    > a&b = 0000 1100
    > 
    > a|b = 0011 1101
    > 
    > a^b = 0011 0001
    > 
    > ~a = 1100 0011
  * `&` - двоичный AND - копирует бит в результат, если он существует в обоих операндах
  * `|` - двоичный OR - копирует бит, если он существует в любом из операндов
  * `^` - двоичный XOR - копирует бит, если он установлен в один операнд, но не в обоих
  * `~` - Binary Ones - оператор дополнения является унарным и имеет эффект «переворачивание» бит
  * `<<` - Двойной левый оператор сдвига.
    * Значение левых операндов перемещается влево на количество бит, заданных правым операндом
    * `a << 2 = 240`, что составляет `1111 0000` 
  * `>>` - Двоичный оператор правого сдвига.
    * Значение левых операндов перемещается вправо на количество бит, заданных правым операндом.
    * `a >> 2 = 15`, что составляет `0000 1111`
* Операторы диапазона
  * `..` - Создает диапазон от начальной до конечной точки включительно. 1..10 -> 1-10
  * `...` - Создает диапазон от начальной точки до конечной точки. 1...10 -> 1-9
* Оператор `defined?`
  * `defined? variable` - True, если переменная инициализирована
  * `defined? method_call` - True, если метод определен
  * `defined? super` - True, если существует метод и он может быть вызван
  * `defined? yield` - True, если передан блок кода
* массивы
  * `<<`
    * добавляет в конец массива элемент, можно цепочку: `a << 1 << 'b' << [3, 4]`
    * еще может быть описан по-разному в разных классах
* `>>`
  * по-разному реализован в разных классах

## BEGIN END, begin end

* `BEGIN { block code }` - блок, который выполняется перед выполнением программы
* `END { block code }` - блок, который выполняется после выполнения программы
* `begin` `end`
  * блок кода
  * не создает новую область видимости
  * в последней строке - результат, который можно присвоить переменной, присвоив ей весь блок

## Исключения

* ключевое слово `rescue` - можно вставлять в блок кода `begin end`
* можно писать несколько `rescue` подряд
* последним можно написать `else` - выполняется только если не было исключений
* после этого еще можно написать `ensure` - этот блок будет выполнен в любом случае
* ключевое слово `retry` - используется в блоке `rescue` - возвращает выполнение на `begin`
* ключевое слово `raise` - чтобы сгенерировать исключение

## Исключения 2

* `throw` - генерирует исключение, и когда оно встречается, управление переходит к `catch`
* `catch` - определяет блок, который помечен с данным именем (может быть символ или строка)
* реализовано с помощью меток
