# Ruby
[На головну](/README.md)

[На Ruby](index.md)


## Типи даних
* NilClass
* TrueClass
* FalseClass
* Numeric
  * Integer
    * Fixnum
    * Bignum
  * Float
  * Complex
* Time
* Date
* String
* Range
* Array
* Hash


## Проки, блоки і лямбди
* **block** - конструкція мови
  * можна передати в якості аргумента
  * в якості аргумента - можна передати тільки 1 штуку
  * записати в змінну чи зберегти не можна
* **proc** - об'єкт
  * можна зберегти в змінну
  * можна передати в якості аргумента
  * в якості аргумента - можна передавати більше 1 штуки
  * елемент классу `Proc`
  * не перевіряється кількість елементів, що передаються
  * `return` завершує виконання коду прока и коду методу де викликаний
* **lambda** - об'єкт
  * елемент классу `Proc`
  * перевіряється кількість елементів, що передаються
  * `return` завершує виконання коду лямбди, код метода де викликана - продовжує виконуватися


## Області видимості змінних і констант
* `var` - локальна змінна
  * доступна тільки в області видимості, де була об'явлена
* `@var` - інстанс змінна
  * доступна в экземплярі і вкладених областях видимості
* `@@var` - класова змінна
  * доступна в класі
  * доступна в класових методах
  * і у всіх інстанс-методах классу
  * також в потомках класу
* `$var` - глобальна змінна, доступна у всій программі
* `CONST` - константа область видимості:
  * клас + потомки - `A::ABC`
  * модуль - `M::ABC`, а також через вкладені модулі `M::M2::ABC` 
  * якщо модуль `prepend`/`include` в класс, то видно через:
    * клас `A::ABC`
    * потомки класу `B:ABC`
    * через модуль `M:ABC`
* `@var` в контексті класу - класова інстанс змінна
  * не буде доступна всередині наслідників
  * не буде доступна всередині екземплярів
  * буде доступна в класових методах
  * не буде доступна в інстанс методах


## Доступність методів
* **public**
  * за замовчуванням
  * відкриті методи - можуть викликатися з будь-яких інших об'єктів
* **private**
  * доступні тільки у класі
  * також доступні потомкам класу
  * також доступні в `included` модуля і класу і потомкам
  * не можуть викликатися з об'єктів
* **protected**
  * викликати можна в класі та екземплярі
  * при виклику метода, викликаючий клас об'єкту повинен бути того ж класу або потомком
    * можна викликати на потомках
    * можна викликати на самому класі
    * якщо в класі - потомок цього ж класу, можно вызывать `protected` методи класу в потомку


## Шукання методів
* йде по ієрархії, доходить до `basicObject`
* потім вертається
* потім друге коло - йде знов і шукає `method_missing` по всій ієрархії


## Модулі
* **основна інфа**
  * це структура даних, яка дозволяє реалізовувати неймспейси і міксини
  * Сукупність методів і констант
  * Методи модуля
    * можуть бути методами екземпляра чи методами модуля
    * коли модуль підключений, методи екземпляру з'являються як методи класу, а методи модуля - ні
    * коли модуль підключений, методи модуля можуть викликатися без створення інкапсулюючого об'єкта
  * потрібні для
    * **простір назв**
    * **міксинів** - загальні методи для кількох класів чи модулів
  * створюється за допомогою `module`
  * може бути повторно відкритий для додавання, змінювання, видалення функціоналу
  * екземпляр модуля:
    * не можна створювати, але є один прикол:
    * `Lol = Module.new` - вот і екземпляр 
    * далі вже не можна створювати інстанси


## Класи
* **основна інфа**
  * клас - екземпляр класу `Class`
  * клас - структура даних, містить в одному місці і дані і методи обробки даних
* **створення класу**
  * створюється безіменний екземпляр класу Class з нашим описом
  * створюється константа
    * те що ми вказуємо в якості назви нашого класу
    * їй присвоюється цей безіменний екземпляр (об'єкт) класу `Class`
  * коли створюємо екземпляр нашого класу - то це ми створюємо екземпляр цього безіменного класу
* **динамічне створення методів і змінних, `attr_accessor`**
  * `define_method(name) { method body }` - створює новий метод в класі
  * `send(name)` - виконує метод класу
  * `send_public(name)` - виконує публічний метод класу
  * `instance_variable_get(name)` - повертає значення змінної
  * `instance_variable_set(name, val)` - створює змінну і пише значення в неї
* `class << self`
  * дає доступ до методів `singleton`
* `singleton`
  * Методи экземпляру зазвичай визначаються в класах.
  * Всі екземпляри одного класу використовують одні й ті ж методи екземплярів.
  * Клас `singleton` знаходиться між об'єктом і його класом.
  * Це дозволяє кожному екземпляру мати свій власний набір методів, що не залежить від інших екземплярів
  * ієрархія: `myObj` -> `singleton` -> `myClass` -> ...


## модуль vs клас
* з модуля не можна зробити екземпляр
* в модулях немає наслідування
* модулі - можна використовувати для міксінів
* модулі використовуються для неймспейсів


## Extend, prepend, include
* **include**
  * Додає в ланцюжок предків перед поточним класом - виходить додатковий найближчий предок
  * Додає функціонал інстансу
  * ієрархія: # BasicObject -- # Object -- *# PlayGuitar (included module)* -- # Person
* **prepend**
  * Додає після поточного класу - виходить додатковий найближчий потомок
  * Додає функціонал інстансу
  * ієрархія: # BasicObject -- # Object -- # Person -- *# PlaySax (prepended module)*
* **extend**
  * Додає функціонал у класові методи


## Символи
* об’єкти скалярного значення, що використовуються як ідентифікатори, що відображають незмінні рядки на фіксовані внутрішні значення
* По суті, це означає, що символи є **immutable strings**
* константа, яка не потребує ініціалізації
* пам'ять виділяється до кінця процесу
* Якщо текстовий вміст об’єкту важливий, то використовуйте `String`. Якщо ідентичність об’єкту важлива, то використовуйте символ
* використовувати в хешах - в якості ключів
* символи не є вказівниками на значення, вони і є значення


## == === equal? eql?
* **==** - загальне порівняння
* **===**
  * спеціальна тулза, котра придумана для `case/when`
  * можна описати цей метод в класі, щоб потім він використався в `case/when`
  * питання "як воно порівнює?" не є коректним, тому що в кожному класі це реалізовано по-своєму
  * на кастомному класі:
    * ```ruby
      def ===(other)
        self == other
      end
      ```
    * вираз після ключового слова `case` являється правою частиною виразу - `other`
    * вираз після ключового слова `when` знаходиться в лівій частині виразу - `self`
* **equal?** - перевіряється ідентичність об'єктів - тупо по `id`
* **eql?** - порівнює хеші об'єктів


## is_a?, kind_of?, instance_of? - методи об'єкту (екземпляру)
* **instance_of?** - true, якщо об'єкт є екземпляром конкретно цього класу
* **is_a?**
  * синонім с `kind_off?`
  * `a.kind_off? A == true`, якщо `a` - екземпляр класу `A`
  * `b.kind_off? A == true`, якщо `b` - екземпляр потомка класу `A`
  * `a.kind_off? ModA == true`, якщо `a` - екземпляр класу, в котрому через `prepend` чи `include` додано модуль `ModA`
  * `b.kind_off? ModA == true`, якщо `b` - екземпляр потомка, в батька котрого через `prepend` чи `include` додано модуль `ModA`
* **kind_of?**
  * синонім з `is_a?`
  * працює так само


## Пріоритетність операторів
* Пріоритет по спаданню
* `!`, `~`, унарний `+`
* `**`
* унарний `-`
* `*`, `/`, `%`
* `+`, `-`
* `<<`, `>>`
* `&`
* `|`, `^`
* `>`, `>=`, `<`, `<=`
* `<=>`, `==`, `===`, `!=`, `=~`, `!~`
* `&&`
* `||`
* `..`, `...`
* `?`, ':'
* modifier-rescue
* `=`, `+=`, `-=`,...
* `defined?`
* `not`
* `or`, `and`
* modifier-if, modifier-unless, modifier-while, modifier-until
* `{ }` blocks


## Безпечна навігація
* Safe navigation
  * якщо поточна ланка в ланцюжку методів = `nil` то далі не йде
  * `User&.address&.street` - не впаде, якщо немає `address` або `User` взагалі пустий


## method_name!
* `User.create` vs `User.create!`
  * `User.create` - якщо не вийде створити поверне просто `nil`
  * `User.create!` - якщо не вийде створити дасть помилку, виключення
* `'abs'.gsub('a','b')` vs `'abc'.gsub!('a', 'b')`
  * перше - не змінить строку, а створить нову
  * друге - змінить саму строку - мутація
* зазвичай це значить, що метод діє на об'єкт, а не повертає результат, але це лише домовленість


## Оператори
* Присвоєння
  * `a += b` -- `a = a + b`
  * `a -= b` -- `a = a - b`
  * `a += b` -- `a = a * b`
  * `a \= b` -- `a = a \ b`
  * `a %= b` -- `a = a % b`
  * `a **= b` -- `a = a**b`
  * ```ruby
    a = 10
    b = 20
    c = 30
    a, b, c = 10, 20, 30
    ```
* Побітові
  * ```ruby
    a   = 0011 1100
    b   = 0000 1101
    a&b = 0000 1100
    a|b = 0011 1101
    a^b = 0011 0001
    ~a  = 1100 0011
    ``` 
  * `&` - двійковий AND - копіює біт в результат, якщо він існує в обох операндах
  * `|` - двійковий OR - копіює біт, якщо він існує в любому з операндів
  * `^` - двійковий XOR - копіює біт, якщо він встановлений в одному операнді, але не в обох
  * `~` - Binary Ones - оператор доповнення є унарним і має ефект «перевертання» біт
  * `<<` - Подвійний оператор лівого зсуву.
    * Значення лівих операндів переміщується вліво на кількість біт, заданих правим операндом
    * `a << 2 = 240`, що становить `1111 0000` 
  * `>>` - Подвійний оператор правого зсуву.
    * Значення лівих операндів переміщується вправо на кількість біт, заданих правим операндом
    * `a >> 2 = 15`, що становить `0000 1111`
* Оператори діапазону
  * `..` - Створює діапазон від початкової до кінцевої точки включно - 1..10 -> 1-10
  * `...` - Створює діапазон від початкової до кінцевої точки - 1...10 -> 1-9
* Оператор `defined?`
  * `defined? variable == true`, якщо змінна ініціалізована
  * `defined? method_call == true`, якщо метод є визначеним
  * `defined? super == true`, якщо існує метод і він може бути викликаним
  * `defined? yield == true`, якщо передано блок коду
* масиви
  * `<<`
    * додає в кінець масиву елемент, можна ланцюжок: `a << 1 << 'b' << [3, 4]`
    * ще може бути описаний по-різному в різных класах
* `>>`
  * по-різному реалізований в різних класах
* `=~`
  * співставлення регулярному виразу, повертає `false` або позицію першого входження
* `||=` - мемоізація(memoization) - значення обчислюється тільки 1 раз, потім повертається
  * `breakfast ||= 'яєшня'`


## BEGIN END
* `BEGIN { block code }` - блок, що виконується перед виконанням програми
* `END { block code }` - блок, що виконується після виконання програми


## begin end
* Блок коду
* Не створює нову область видимості
* В останній стрічці - результат, котрий можна присвоїти змінній, присвоївши їй весь блок


## Виключення
* Ключове слово `rescue` - можна вставляти в блок коду `begin end`
* Можна писати кілька `rescue` підряд
* Останнім можна написати `else`, котре виконується тільки якщо не було виключень
* Після цього, ще можна написати `ensure` - цей блок буде виконано в будь-якому випадку
* ключове слово `retry` - використовується в блоці `rescue` - повертає виконання на `begin`
* ключове слово `raise` - щоб згенерувати виключення


## Виключення throw catch
* `throw` - генерує виключення і, коли воно зустрічається, керування переходить до `catch`
* `catch` - визначає блок, котрий помічений с даною назвою (може бути символ чи строка)
* реалізовано за допомогою міток


## puts, print, p, pp
* `puts`
  * друкує усе, що передається в метод
  * в кінці символ переводу строки
  * все що передається перетворюється в строку завдяки методу `.to_s`
  * якщо передати масив - виведе значення
  * метод повертає `nil`
* `print`
  * схожий на `puts`, але не має вкінці символ переводу строки
  * якщо передати масив - виведе масив з дужками
  * метод повертає так само `nil`
* `p`
  * для виводу використовує метод `inspect`, котрий є в будь-якого об'єкта
  * виводить те, що передали в більш інформативному вигляді
  * метод повертає сам об'єкт
* `pp`
  * версія `p`, котра виводить об'єкт в більш читабельному вигляді


## Константи
* Константи - все, що починається з великої літери, або повністю великими літерами
* Назви модулів та класів - теж константи


## dup vs clone
* `clone` копіює клас `singleton`, в той час, як `dup` ні
* `clone` зберігає заморожений стан, в той час, як `dup` ні
* при роботі з `ActiveRecord` - `dup` створює новий об'єкт без `id`, `clone` - копіює з `id`


## Rack і вся схема роботи
* Rack - це специфікація
  * протокол, як має комунікувати між собою аплікейшн сервер і аплікуха
  * набір описаних правил
  * Rack-сумісний сервіс має описувати такий-то метод, такий-то респонс,...
* Rack middleware
  * Rack - в центрі запитів - і якісь маніпуляції робити з цими запитами - це воно і є
  * реалізація шаблону проектування конвеєра для веб-серверів, що юзають Rack
* Rack application приймає:
  * puma прийняла хеш з хттп реквестом і запихнула в хеш env
  * Rack application приймає env
  * Rack application розпарсює env
* Rack application вертає масив з трьома елементами:
  * код відповіді
  * хедери
  * боді
* Puma - це app server
* Nginx - це web server
* Rails - аплікуха, Rack-сумісний сервіс
* ось як все працює:
  * browser -> nginx -> puma -> rack -> rails


## Шлях реквесту
* Браузер
* GET-реквест
* Nginx - web server
* Puma - application server
* Rack (+Middleware)
* Rails
  * config.ru
  * application.rb
  * енвайрнменти
  * routes
  * Controller
* Response to Rails
* to Rack
* to Puma
* to Browser


## Rake
* автоматизація процесів
* типу Makefile
* наприклад `rake db:migrate`
* в rake таски можна передавати параметри такими способами:
  * засобами rake - `$ rake add\[1,2\]`
  * environment variable - `$ RAILS_ENV=production bundle exec rake ...`
  * за допомогою ARGV - `$ rake add 1 2`
  * за допомогою Ruby OptionParser (найважчий спосіб) - `$ rake add -- --one 1 --two 2`


## Потоки
* в рубі - зелені потоки
  * мова дає інструменти для роботи з потоками
  * але потоки виконуються послідовно
  * почучуть кожний
  * рубі сам приймає рішення коли пригати між ними
  * нема ніякої паралельності
* GIL - контролює шо б в рубі були зелені потоки
  * Global Interpreter Lock
  * Рубі інтерпретатор написаний на сі, Сі - потоконебезпечний, тому і інтерпретатор - теж
  * Потоконебезпечний - з потоками нема проблем, поки вони не використовують одні й ті самі дані
* Є купа реалізацій Ruby, окрім Сішного: JRuby, TruffleRuby,..
  * і вот наприкдад в JRuby - інтерпретатор на Java - і от там - є реальні потоки і паралельність


## require, require_all, require_relative, load
* `require`
  * Хочу посилатися та виконувати код, який не записаний у поточному файлі, сторонні файли, gems
  * Виконує пошук у папках, вказаних в `$LOAD_PATH`
  * Грузить тільки 1 раз, навіть якшо прописати двічі - відстежує що вже було завантажено через `$LOADED_FEATURES`
  * Існує два способи форматування рядка (аргументу):
    * або як абсолютний шлях: `require './app/example_file.rb'`
    * або як скорочене ім’я: `require 'example_file'`
  * Зазвичай використовується для завантаження гемів
* `require_relative`
  * Підмножина `require`
  * Для файлу, який відноситься до поточного файлу (загалом, у тому самому каталозі проєкту)
  * Виконує пошук від поточної папки (файл з якої на даний момент виконується, в константі `__FILE__`)
* `require_all`
  * Це gem
  * Підмножина `require`
  * Працює як `require` але дозволяє конфігурувати на більш високому рівні
  * Грузить всі файли каталогу
  * Зазвичай використовується для завантаження моїх файлів
* `load`
  * Грузить кожного разу, ігнорує вже завантажене
  * Можна обгорнути код в анонімний модуль


## Ітератори
* `each` - біжить по елементам і робить дії в блоці, не трогає об'єкт
* `reverse_each` - біжить по елементам в зворотньому напрямку
* `map` - біжить по елементам і робить дії над елементами об'єкту, повертає новий об'єкт
* `map!` - біжить по елементам і робить дії над елементами об'єкту, змінює існуючий об'єкт
* `collect` - аліас `map`
* `select` - фільтрує елементи, якщо блок вертає `true` елемнт лишається, повертає новий об'єкт
* `select!` - фільтрує елементи, якщо блок вертає `true` елемнт лишається, змінює існуючий об'єкт
* `find` - теж фильтрує, але повертає лише один перший, який задоволняє умові
* `detect` - аліас `find`
* `reduce` - Застосовує бінарну операцію (суму, ділення, ..) до кожного елемента, зберігає значення у змінній
* `inject` - аліас `reduce`
* `all?` - перевіряє умову в блоці для кожного елементу і повертає true, якщо кожний елемент задовольняє умову
* `any?` - перевіряє умову в блоці для кожного елементу і повертає true, якщо хоч 1 елемент задовольняє умову
* `none?` - перевіряє умову в блоці для кожного елементу і повертає true, якщо ні 1 елемент не задовольняє умову
* `include?` - перевіряє наявність переданого значення серед елементів
* Number
  * `3.times {  }` - 3 рази
  * `3.upto(10) {  }` - з 3 до 10
  * `10.downto(3) {  }` - з 10 до 3
  * `3.step(10, 2) {  }` - з 3 до 10 крок - 2
* String
  * `s.each_char {  }` - перебір символів
  * `s.each_line {  }` - перебір строк
* Array
  * `each_index {  }` - в блоці буде індекс
* Hash
  * `each_key {  }` - в блоці буде ключ


## String
* `scan` - шукає в стрінгі значення за паттерном
  * має дві форми запису:
    * без блоку - повертає `array`
    * з блоком - стартує блок при кожному співпадінні + передача співпадіння в блок
  * після виконання в змінну `$&` зберігається останнє співпадіння


## Різне
* в рубі не є об'єктами: блоки, ключові слова, методи
* передача параметрів в рубі: по ссилці все, крім символів та чисел


## length vs size vs count
* `length` - рахує кількість елементів у масиві
* `size` - синонім `length`
* `count`
  * може рахувати кількість елементів: `[1, 2, 3].count # 3`
  * може рахувати кількість вказаних параметром елементів: `[1, 2, 3, 3, 4].count 3 # 2`
  * може рахувати кількість елементів за умовою переданою в блоці: `[1, 2, 3, 4].count { |i| i > 2 } # 3`
