# SQL
[На головну](/README.md)


## Типи операцій
* **DML** (Data Manipulation Language) - Команди для роботи з даними
  * SELECT
  * INSERT
  * UPDATE
  * DELETE
  * MERGE
* **DDL** (Data Definition Language) - Команди для роботи з структурою
  * CREATE
  * ALTER
  * DROP
  * RENAME
  * TRUNCATE
* **TCL** (Transaction Control language) - Команди для транзакцій
  * COMMIT
  * ROLLBACK
  * SAVEPOINT
* **DCL** (Data Control Language) - Давать і забирать права у юзерів
  * GRANT
  * REVOKE


## SELECT statement
* 3 фундаментальні концепції
  * Projection - вибір стовпчиків з таблиці
  * Selection - вибір рядків з таблиці
  * Joining - об'єднування таблиць
* Select - тільки витягує дані і ні в якому разі не змінює
* **Projection**
  * `SELECT * FROM table;`
    * `*` - вибрати усі колонки
    * `FROM` - звідки брати, вказується таблиця
    * `;` - кінець команди, розділення між кількома командами, хоча одну команду можна писать в кілька рядків
  * `SELECT column(s) FROM table;`
    * `column(s)` - вказуємо 1 або кілька колонок таблиці, називається **select list**
    * `first_name, last_name` - через кому перераховуються назви колонок
  * `SELECT DISTINCT column(s) FROM table;`
    * `DISTINCT` - запезпечує унікальність значень по колонці або кількох
    * Має стояти перед перерахуванням колонок
    * Якщо колонок вказано кілька - то унікальність буде вираховуватися по всім колонкам
    * Неможливо вказуючи `DISTINCT` вимкнути його вплив на котрусь з вказаних колонок
    * `DISTINCT` склеює усі `null` в одне, це буде одне з унікальних значень
  * `SELECT column(s), expression(s) FROM table;`
    * `expression(s)` - вказуємо 1 або кілька виразів
    * `SELECT salary*2+employee_id FROM table;` - ось такий вираз з використанням колонок
    * `SELECT first_name, salary*2, salary FROM table;`
    * Операції для виразів для різних типів даних:
      * Числа
        * звичайні арифметичні: `+ - \ * ()`
        * якщо є хоч один `null` - результатом обчислення буде `null`
      * Дати
        * `date_end-date_start` - поверне кількість днів
        * `DATE_ADD(start_date, INTERVAL 10 DAY)` - додати кількість днів до поточної дати
          * `ADDDATE(start_date, 10)` - робить те саме
          * для Oracle SQL `date_start+7`
      * Тексти
        * `CONCAT(col1, col2)` - конкатенація - об'єднує колонки, якщо колонка не текстова, то значення перетворюється в текстове
        * `null` - робить так, що весь вираз буде `null`
          * для Oracle SQL - `col1||col2`, а також `null` - рахує як пустоту, загальний результат буде не `null`
  * `SELECT column(s) alias, expression(s) alias FROM table;`
    * `alias` - псевдонім на колонку або вираз
    * Синтаксис:
      * `column1 col1` - просто чере пробіл
      * `column1 as col1` - додаємо `as` - для читабельності
      * `column1 "col 1"` - якщо хочу використовувати пробіл - подвійні лапки треба
  * `SELECT 30*90;`
    * Просто обчислення якихось речей
      * для Oracle SQL - має обов'язково бути `FROM table`, тому там є спеціальна таблиця `dual` (вона 1х1)
  * `SELECT 'it''s my life'`
    * Для застосування одинарних лапок в текстовому значенні - треба їх подвоювати
* **Selection**
  * `SELECT ... FROM table WHERE condition(s)`
    * `condition(s)` - 1 або кілька умов
    * Числа - пишуться без лапок, а текстові значення в одинарних лапках
    * **implicit type conversion** - неявне перетворення типу
      * `...WHERE col1 = '1000'` якщо число в лапках написати - то з текста зробиться число
      * `...WHERE col1 = '2022.07.02'` якщо дату в лапках написати - то з тексту зробиться дата
  * Оператори порівняння:
    * `= < > <= >= <> !=`
    * `col1 BETWEEN 'val 1' AND 'val 2'` - перевіряє належність до інтервалу
    * `col1 IN(val1, val2)` - перевіряє чи є значення в масиві значень
    * `IS NULL` - перевіряє чи значення колонки `null`, а так - не правильно: `col1 = NULL`
    * `col1 LIKE 'a%b_c'` - пошук по патерну
      * `%` - 0, 1 або кілька символів
      * `_` - 1 символ
      * `col1 LIKE '5\%` - таким чином екрануються спецсимволи `%` та `_` - після слешу наступний 1 символ екранується
        * `col1 LIKE '5^% ESCAPE '^'` - таким чином для екранування можна використати свій символ
  * Логічні оператори або булеві оператори (повертають `true` чи `false`):
    * `col1 AND col2` - повертає `true`, якщо всі частини `true`, якщо перше не `true` - тоді далі не йде
    * `col1 OR col2` - повертає `true`, якщо хоч одна частина `true`, після першого `true` далі не йде
    * `col1 NOT expression` - змінює значення умови на протилежне
      * `WHERE NOT (col1 = 'val1')`
      * `WHERE col1 NOT LIKE 'val1`
      * `WHERE col1 NOT IN (val1, val2)`
      * `WHERE col1 NOT BETWEEN 'val1' AND 'val2`
      * `WHERE col1 IS NOT NULL`
  * Пріоритетність в порядку спадання:
    * `()`
    * `/`, `*`
    * `+`, `-`
    * `=`, `<`, `>`, `>=`, `<=`, `<>`, `!=`
    * `IS`, `LIKE`, `IN`
    * `BETWEEN`
    * `NOT`
    * `AND`
    * `OR`
  * Сортування
    * `WHERE condition(s) ORDER BY {column(s)|expression(s)|position} {ASC|DESC}`
      * Сортування працює в самому кінці, після обчислень і фільтрації
      * `column(s)` - 1 або кілька колонок, за якими сортувати
      * `expression(s)` - 1 або кілька виразів, за якими сортувати - вказувати або аліас або як вказано в **select list**
      * `position` - число, що вказує на номер колонки, по якій сортувати
      * `ASC|DESC` - порядок сортування по зростанню і спаданню відповідно
      * `-` - перед назвою колонки дає змогу впливати на сортування `null`
        * `ORDER BY -col1 ASC` - відсортує як `DESC`, але `null` буде на початку
        * `ORDER BY -col1 DESC` - відсортує як `ASC`, але `null` буде вкінці
          * для Orace SQL - використовується додаткова конструкція `NULLS FIRST` або `NULLS LAST`
      * `ORDER BY 2 DESC`
        * `SELECT * FROM` - буде обиратися колонка 2 в таблиці
        * `SELECT col1, col2 FROM` - буде обиратися колонка 2 в **select list**
      * `ORDER BY col1 DESC, col5, 2 DESC` - можна комбінувати як завгодно
  * Групування
    * `SELECT group-function(s) WHERE condition(s) GROUP BY {column(s)|expression(s)} ORDER BY...`
      * Групування працює в зв'язку з функціями агрегації
      * Групування виконується після `WHERE`
      * Групувати можна по значенню функції: `GROUP BY MIN(col1)`
      * Якщо групуємо по `col1`, то цей `col1` можна використати в SELECT
      * Можна групувати по кільком колонкам
    * `GROUP BY column(s)|expression(s) HAVING expression(s)`
      * Таке саме як `WHERE` тільки для фільтрації в `GROUP BY`
* **Joining**
  * `INNER JOIN`
    * Стовпці мають бути одного типу даних
    * Об'єднують і виводять рядки, що задовольняють рівності або нерівності
    * Якщо не задовольняють умові - такі рядки не виводяться
    * `NATURAL`
      * `SELECT ... FROM table1 t1 NATURAL JOIN table2 t2`
      * Цей джойн дуже дерев'янний, мінусів повно
      * Вибір колонки автоматичний, не можна вказати колонку по якій зв'язувати
      * Якщо немає ні одної колонки з однаковою назвою - працює як `CROSS JOIN`
      * Якщо об'єднує по кільком колонкам - виходить якась дічь
      * Якщо є одна колонка з однаковою назвою і треба саме по ній об'єднати - тоді відпрацює нормально
    * `USING (col1{, col2})`
      * `SELECT ... FROM table1 t1 JOIN table2 t2 USING (col1)`
      * Цей джойн краще, можна вказати 1 або кілька колонок
      * Колонка має бути в обох таблицях, інакше - помилка буде
    * `ON (t1.col1 = t2.col2{ AND|OR t1.col3 = t2.col4})`
      * `SELECT ... FROM table1 t1 JOIN table2 t2 ON (t1.col1 = t2.col1)`
      * Найбільш вдалий джойн
      * Дозволяє вказати повністю умову, не обов'язково зв'язувати по однаковій колонці
  * `EQUI JOIN` and `NON EQUI JOIN`
    * Це тей самий джойн, але різна побудова умови
    * `SELECT ... FROM table1 t1 JOIN table2 t2 ON (t1.col1 = t2.col2)` - це `EQUI JOIN` - тобто фігурує знак `=`
    * `SELECT ... FROM table1 t1 JOIN table2 t2 ON (t1.col1 != t2.col2)` - це `NON EQUI JOIN` - тобто фігурують знаки `!= <> < >`
  * `SELF JOIN`
    * `SELECT ... FROM table1 t1 JOIN table1 t2 ON (t1.col1 = t2.col2)`
    * Зав'язка таблиці на саму себе
    * Використовується, наприклад, для таблиць, в котрих реалізована ієрархія якась
      * працівник - підлеглий
      * папка - підпапка
  * `OUTER JOIN`
    * Виводить рядки, що задовольняють умові + рядки що не задовольняють умові
    * `LEFT OUTER JOIN t2 ON(...)` - окрім результата `INNER JOIN` ще виводить всі рядки для яких умова не виконується з лівої таблиці
    * `RIGHT OUTER JOIN t2 ON(...)` - окрім результата `INNER JOIN` ще виводить всі рядки для яких умова не виконується з правої таблиці
    * `FULL OUTER JOIN t2 ON(...)` - окрім результата `INNER JOIN` ще виводить інфу з обох таблиць
  * `CROSS JOIN`
    * `SELECT ... FROM table1 CROSS JOIN table2`
    * Cтворює набір результатів, який є кількістю рядків у першій таблиці, помноженою на кількість рядків у другій таблиці
    * Якщо не використовується `WHERE`, то це тупо table1.rows * table2.rows
    * Декартовий добуток
    * Якщо використати `NATURAL JOIN` і в таблиць немаєжодних однакових колонок - то видасть не помилку, а теж `CROSS JOIN`
  * Oracle синтаксис
    * `INNER JOIN` - `SELECT ... FROM table1 t1, table2 t2 WHERE t1.col1 = t2.col2`
    * `RIGHT OUTER JOIN` - `SELECT ... FROM table1 t1, table2 t2 WHERE t1.col1(+) = t2.col2`


## Підзапити
* Підзапит це окремий запит, що вкладений всередину основного запита, **inner query**
* Працює так само, але запускєаться перед зовнішнім запитом, **outer query**
* Підзапит пишеться в дужках
* Можна більше 2х рівнів вкладеності
* 1 раз виконується і потім результат використовується в **outer query**
* Може використовуватися в різних місцях:
  * В **select list**:
    * `SELECT col1, (SELECT MIN(col1) FROM table2) AS col2 FROM table1`, можна кілька штук використовувати
  * В блоці `WHERE`:
    * `SELECT ... FROM table1 WHERE col1 > (SELECT AVG(col1) FROM table1)`
    * `SELECT ... FROM table1 WHERE col1 IN (SELECT col1 FROM table2)`
  * В блоці `FROM`:
    * `SELECT col1 FORM (SELECT col1, col2 FROM table2 t2 JOIN table3 t3 ON (t2.col2 = t3.col3)) ...`
    * Типу створюємо свою кастомну таблицю
    * Після відпрацювання цього запиту ця табличка пропаде
  * В блоці `HAVING`:
    * `GROUP BY col1 HAVING MAX(col2) > (SELECT 2*5000)`
* Типи:
  * **single row** - повертає 1 рядок
    * **scalar** - повертає 1 рядок і 1 колонку
    * для цього типу можемо використовувати всі варіки які використовуєм для **multiple row**
  * **multiple row** - повертає більше 1 рядка
    * якщо для **single row** можна використовувати `=` або `!=`, то для **multiple row** - використовуємо `IN` та `NOT IN`
    * якщо для **single row** можна використовувати `<` або `>`, то для **multiple row** - використовуємо:
      * `WHERE col1 > ANY(SELECT col2 FROM table2 WHERE...)` - перевірка "більше котрогось"
      * `WHERE col1 > ALL(SELECT col2 FROM table2 WHERE...)` - перевірка "більше будь-якого"
  * **corellated subquery**
    * Виконується стільки разів, скільки рядків містить таблиця
    * По суті виходить як функція з параметрами
    * Спочатку він запитує необхідну інформацію з **outer select**, отримує її, використовує і потім повертає результат виконання
    * Зовнішній запит починає виконання
    * Інфа з зовнішнього передається у внутрішній запит
    * Виконується внутрішній запит
    * Передається інфа у зовнішній запит, де і порівнюється
    * `SELECT * FROM table1 t1 WHERE t1.col1 > SELECT AVG(t2.col2) FROM table2 t2 WHERE t2.col2 = t1.col1`


## Функції
* Single-row функція - приймає скільки-то рядків і віддає стільки ж рядків
  * Дуже багато всяких функцій є
* Multiple-row функція - приймає рядки, а віддає 1 рядок (функції агрегації)
  * Функції агрегації не можна використовувати з single-row функціями
  * `COUNT({DISTINCT}col1|*)` - кількість рядків, якщо вказана колонка, а не `*`, то не буде рахувати рядки з `null`
  * `SUM({DISTINCT}col1)` - сумує значення всі, `null` ігнорує - працює тільки з числами
  * `AVG(col1)` - середнє арифметичне - працює тільки з числами
  * `MIN` і `MAX` - мінімальне і максимальне значення відповідно, працює не тільки з числами
* Nested функція - вкладена функція, яка слугує параметром для іншої
